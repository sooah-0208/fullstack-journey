# ✅Javascript(ECMAScript)
- 객체 지향 프로그래밍 OOP
- `JS` 혹은 `ES`라고 부름
- 주로 frontend에 사용하는 프로그램(백엔드엔 한계가 있음)

script의 src 확인하는 방법: 콘솔->Sources->js파일

script도 body처럼 스크립트 순서대로 출력이 됨
```
<script>어쩌구</script>
<script>저쩌구</script>

=>어쩌구저쩌구
```

## ⭐자료형
### 🟡 [기본 타입] Primitive Type
		- number    : 숫자(정수, 실수)
		- bigint    : 정수 -(2의 53승 -1) ~ 2의 53승-1
		- string    : 문자열
		- boolean   : 논리값(true, false)
		- undefined : 초기화되지 않은 상태(함수에서 출력값이 없을 때), 변수 초기화에 사용(변수에서 입력값이 없을 때) ==>javascript에서만 사용됨!
		- null      : 객체 변수 초기화 사용
		- NaN       : Not a Number(영역에 숫자가 들어가지 않았을 때(문자열이 들어있을 때)  
    **number, 특수기호 ⊂ string** => 그래서 숫자가 포함된 문자열은 문자열로 봄    
    ->그럼 왜 숫자열과 문자열이 나눠져있나요? = 계산을 하기 위해서. 문자열은 계산식에서 제외됨  
		5+1=6  
		5+"1"=51('5'와'1'을 다 문자로 봐서 계산이 안됨)  

### 🟡 [참조 타입] 참조형, Reference Type
		- array
		- function
		- ...

### 🟡 [변수선언]
 var 변수명; (형식)
```
var num;
document.write('num >>' +num);
document.write('<br>');
document.write('num type >>', typeof num);
document.write('<br>');
```

typeof: 변수가 가진 자료형이 뭐인지

#### 💡 값 비교시
==: 안에 요소만 비교
===: 자료형도 비교
ex) 5=="5": true
    5==="5": false

## 🔷주요 기능 정리
1️⃣ let / const 블록 범위 변수 선언

- 기존 var는 함수 스코프 → 예측 어려움
- ES6부터는 블록 단위 스코프 지원
```
let a = 10;
const b = 20;

a = 30; // ✅ 가능
b = 40; // ❌ TypeError: const 값 변경 불가
```
2️⃣ 템플릿 문자열 (Template Literals)

- `+` 대신 `백틱`으로 문자열을 연결(WHY? `+`는 숫자열에 들어가면 계산이 되어버리기 때문)
- 변수 내삽도 가능하게 만든 기능 = ${}!

3️⃣ 화살표 함수 (Arrow Function)
```
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5  
```
함수를 쓸 때 funcion 풀로 다 적기 번거로워서 변경함  


# ✅ 문자열
'(백틱), ``안에 들어가면 다 문자열이 됨
```
1️⃣ var message = '저는 ' + name + '이고, 나이는 ' + age + '세 입니다.';
2️⃣ var messageTwo = `저는 ${name}이고, 나이는 ${age}세 입니다.`;
```
둘 다 문자열이 됨

# ✅ 문자열 함수
## `.` 점 연산자 `변수.(함수)`  

**if( var a = "가나다라" )**
- 길이 측정: 변수 `length`
- 특정 문자 변경:  
  1) `replace(`기존`,'변경`)` 해당되는 문자열 중 첫번째만 변경  
  2) `replaceAll(`기존`,'변경`)` 해당되는 모든 문자열 변경
- 문자 추출:
  1) `substring(시작 인덱스, 끝 인덱스)`
  2) `slice(시작 인덱스, 끝 인덱스)`  
	=> 시작 인덱스부터 끝 인덱스까지의 문자를 추출해줌  
	=>()안에 들어가는 숫자는 다른 함수값으로도 대체 가능함  
  ex) `(0, a.length)`라고 하면 `a.length=4` ==>즉, (0,4)가 됨
  - 끝 인덱스를 입력하지 않으면 자동으로 문자열 끝까지 인식함
🤔그럼 인덱스를 모를때는요?⬇
- 문자의 위치(인덱스) 리턴: `indexOf('문자')`  
  ()안이 한 글자가 아니면 해당 문자를 포함하는 `첫번째 글자의 인덱스`를 리턴해줌  
  없을 경우: `-1`  
  ex) a.indexOf("가나")= 0 / a.indexOf('나다라')= 1    
- 특정 문자를 기준으로 분리: `split('')`
  기준으로 사용된 문자는 요소에 포함되지 않음  
     ex) a.split("나")= (2) ['가', '다라']  
  `` ` ` `` => 문자열을 각각 문자로 나눈다는 이야기  
     ex) a.split(``)= (4) ['가', '나', '다', '라']  
- 특정 문자 추가:  
  1) `padStart(문자열 전체 길이, '추가할 문자')`: 변수의 시작점 앞으로 채움
  2) `padEnd(문자열 전체 길이, '추가할 문자')`: 변수의 끝지점 뒤로 채움  
  ex) a.padStart(7,'@')= '@@@가나다라' / End='가나다라@@@'
- 특정 문자 찾기: `includes('') => 문자가 포함되면 true/ 없으면 false (대소문자 구분함)
- 반복: `repeat(횟수)`
- 대소문자 변경:
  1) 대문자로: `toUpperCase()`
  2) 소문자로: `toLowerCase()`
-공백 제거:
  1) `trim()`: 양쪽 공백 제거
  2) `trimStart()`: 오른쪽 공백 제거
  3) `trimEnd()`: 왼쪽 공백 제거
  => 총 문자열 묶음에서 양쪽 공백만 제거해줌  
  ==> 문자열의 모든 공백을 제거하고싶으면? `replaceAll(" ","")`

### 💡 인덱스
"GOOD~"을 예시로 들면  
인덱스는 G앞이 0, G O 사이가 1 ... D ~ 사이가 4, ~ 뒤가 5   
그래서 (1,4)라고 하면 1=O, 4=~, (-4)는 O  
->이해하기 쉽게 정리하면 index는 문자열 갯수 -1(=lenght -1)  
### 💡 할당&선언
변수를 정해줌 =할당 / 변수의 값을 정해줌=선언  
var age: 할당  
var age = 20; 선언  







