## CREATE문
```
CREATE TABLE edu.board (                  #DB.테이블명
    `no` INT AUTO_INCREMENT PRIMARY KEY,  #프라임키 지정
    `title` VARCHAR(40) NOT NULL,         #NOT NULL = 빈 값 불가
    `content` VARCHAR(500) NOT NULL,
    `delYn` TINYINT(1) DEFAULT 0,         #DEFAULT =  기본값 지정

    `user_id` INT NOT NULL,

    CONSTRAINT fk_board_user            
    FOREIGN KEY (`user_id`)         #FOREIGN KEY지정
    REFERENCES edu.`user`(`id`),    #어디서 가져오는지

    `regDate` DATETIME DEFAULT CURRENT_TIMESTAMP,
    `modDate` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
```
## SELECT문
```
SELECT #SQL 검색 키워드
*      #컬럼 전체를 가져오는 키워드
FROM   # 위치
edu.employees # FROM의 대상
;  -> employees에 저장된 테이블을 가져와줌
```

`*`위치에 원하는 Col 명을 넣으면 해당 컬럼들만 추출해서 보여줌
```
SELECT employees.first_name, 
		 employees.last_name,
		 salaries.salary
FROM edu.employees, edu.salaries
WHERE employees.emp_no = salaries.emp_no;
```
이런식으로 셀렉할 컬럼을 자세하게 하면 할수록 값을 가져오는 속도가 빨라짐
Where이 조건
부정은 `!=` OR `<>`

## JOIN

- 두 개 이상의 테이블을 공통된 COL기준으로 합쳐줌
- FROM 부분에서 여러 테이블을 부를 때
`FROM edu.employees, edu.salaries`이 방법 대신 JOIN을 사용함
- 여기서는 `emp_no`가 양쪽 테이블에 같이 있어서 합쳐준거임
- 기본값이 `INNER JOIN`(생략하고 JOIN 쓰면 INNER JOIN이 됨)
```
SELECT em.first_name, 
	   em.last_name,
	   sa.salary
FROM edu.employees AS em
INNER JOIN edu.salaries AS sa
ON (em.emp_no = sa.emp_no);
```
- 행 수가 많은 쪽을 메인으로 잡고 JOIN 앞에 써줌
- Join 앞에 오는 Data가 가장 첫 열로 옴
- `ON()`: JOIN문의 조건문(WHERE문이랑 같음)
    AND로 다른 조건을 추가할 수 있음
```
ON (t.emp_no = e.emp_no AND t.to_date = '9999-01-01')
```

- LEFT JOIN: 왼쪽 테이블의 모든 행 + 오른쪽 조건에 일치하는 행
=> 왼쪽 기준 전체 데이터를 가져와주고, 오른쪽에 일치값이 없으면 NULL로 채워줌

- RIGHT JOIN: 오른쪽 테이블의 모든 행 + 왼쪽과 조건 일치하는 행
=> 오른쪽 기준 전체 데이터를 + 왼쪽 겹치는 데이터
=> MySQL/MariaDB에서는 사용 가능하지만 LEFT JOIN보다 덜 사용

- CROSS JOIN: 테이블 간 모든 조합을 반환
=> A*B를 구해줌
=> 조합 수가 매우 커질 수 있음. ON 조건을 사용하지 않음

### 테이블 명이 너무 길어요!
AS(= alias(에일리어스))로 별명 지어주기


❗ 셀렉할 땐 각 테이블을 확인해가며 어떤 데이터가 어떻게 저장되어있는지 알아야 원하는 부분만 얻을 수 있음

❗ MariaDB에서는 select로 새로운 컬럼 만들 수 있음
union:select위아래를 합쳐 한 행으로 보여줌
```
SELECT 1+2 AS no
union
SELECT 2;
```

## 서브 query
```
SELECT (SELECT salary FROM edu.salaries
WHERE emp_no = 10001
AND from_date = '1986-06-26')
+
(SELECT salary AS f FROM edu.salaries
WHERE emp_no = 10001
AND from_date = '1987-06-26')
AS y1986_y1987
```
()안에 select로 원하는 값을 빼온 후 다시 select하여 행위를 더하는 것
값을 합하거나 열거하거나 할 때
()안의 컬럼은 단 하나만 가능함

## DISTINCT: 중복 제거
```
SELECT DISTINCT dept_no FROM dept_manager ORDER BY 1;
```
---

## IFNULL(셀렉문, 원하는 값)
: 셀렉문 안의 내용이 null이면 값을 원하는 값으로 바꿔줌
단, 자료형은 같아야함
```
SELECT
  name,
  IFNULL(phone, '없음') AS phone
FROM users;
```

## insert: table에 값 넣기
```
INSERT INTO edu.test
(`name`, `regdate`)
VALUE ('안뇽여러분~~~희희희', NOW());
```
## update: 조건에 맞는 행 변경
```
UPDATE edu.test SET `name` = '수아 생일', `regdate` = '1999-02-08'
WHERE `no`=3;
```
## delete: 조건에 맞는 행 삭제
```
DELETE FROM edu.test
WHERE `no`=2;
```
## drop: table 완전 삭제/초기화
```
DROP TABLE edu.test;
```
## truncate: drop 후 create 동시에 해줌(해당 테이블이 존재하고 있을 때 내용만 초기화 시키고 싶을 경우 사용)
---

## 여러 조건문

**기본!!!**
### WHERE: 조건식
비교연산자 사용 가능
`!=` = `<>` NOT은 이렇게 두개로 적을 수 있음
`AND`: 여러 조건을 만족해야하는 경우

### 집합연산자
`IN(값)`
```
SELECT dept_no FROM dept_manager
WHERE dept_no IN ('d001','d002','d003');
```
()안의 내용과 완벽하게 같은 값만 가져와 줌
NOT IN(값)하면 값을 제외한 값만 추출해줌
얘도 조건문이라 where, on 조건문 다음에 적어주면 됨

### 문자열 집합
`LIKE '값'`
값과 완벽하게 같은 값만 추출해줌
`'a%'`: a로 시작하는 값
`'_a%'`: 두번째 글자가 a인 값 => `_`는 자릿수, 여러개 넣을 수 있음
`'%a'`: a로 끝나는 값

### null 연산자:
`is null`: 값이 null이면 TRUE, null인 행만 가져옴
`is not null`:	값이 null이 아니면 TRUE, 값이 있는 행만 가져옴

---

`INSERT` – 데이터 추가
```
INSERT INTO users (name, age)
VALUES 
('수아', 23),
('민수', 25),
('지영', 22);
```
컬럼 순서랑 값 순서가 같아야함(자료형도)

`limit (오프셋(=시작index), 거기부터 몇개)`:
시작번호 생략하면 1번부터 시작함
오프셋은 무조건 0부터 시작, 인덱스랑 같다고 생각하면 됨
6번 행을 가져오고 싶으면 오프셋=5
ex) limit(5,3)
하면 5,6,7번째 행 가져옴

`SUBSTR(문자열, 시작자리, 끝자리)`
- 문자열을 Num으로도 읽을 수 있게 해줌
- 시작 위치는 무조건 1부터!, 길이는 생략하면 끝까지 추출해줌

---
# 집계함수
count(컬럼명 / *)	로우 개수 - null 제외
sum(컬럼명)	합
avg(컬럼명)	평균
max(컬럼명)	최댓값
min(컬럼명)	최솟값

# 정렬
- `GROUP BY`: 같은 값의 행들을 하나의 그룹으로 묶음
❌ 이게 없으면 에러 남  
👉 emp_no는 개별 값  
👉 COUNT(emp_no)는 집계 결과  
👉 같이 쓰려면 그룹 기준이 필요  
emp_no별로 묶은 후 그 묶음마다 카운트를 계산함

📌 결과:
```
emp_no = 10001 → 17개
emp_no = 10002 → 1개
```

HAVING: 그룹으로 묶은 **결과**에 조건을 걸어주는 필터
```
SELECT dept_no, COUNT(dept_no) AS 인원수
FROM edu.dept_emp
WHERE dept_no IN ('d001','d002','d005')
GROUP BY dept_no;

----

SELECT dept_no, COUNT(dept_no) AS 인원수
FROM edu.dept_emp
GROUP BY dept_no
HAVING  dept_no IN ('d001','d002','d005');
```
이렇게 위 아래가 같은 결과가 됨

## 문자 연결
select concat('one', 'two', 'three');
-> onetwothree
SELECT 'one' + 'two' + 'three';
->0 
문자열은 계산할 수 가 없기 때문에 CONCAT 써서 이어줘야함

## 정렬 
ORDER BY (기본이 ASC): 오름차순
ORDER BY DESC: 내림차순

## 포멧팅

날짜 포멧팅
```
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %h:%i:%s');
```
- DATE_FORMAT(값, 바꿀 방법들)
- NOW() 현재 날짜 표출 해주는 함수

## SQL 실행 순서
1. FROM
2. WHERE        ← 개별 행 필터
3. GROUP BY     ← 그룹 생성
4. HAVING       ← 그룹 필터
5. SELECT
6. ORDER BY

SQL은 다른 것들과 달리 위에서부터 순서대로 실행하지 않음
알아서 정해진 순서대로 실행시킴